<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
     /*
      面向对象
      类           实例
      JS常见的内置类 Array  Object(基类)   function string  number regexp  date
      JS 中常见的设计模式：
      单例模式
      高级单例模式  函数执行返回一个对象，可以有自己私有的内容
      工厂模式   批量产生单例模式
      构造函数模式  new 执行函数的时候，会在变量提升之后 ，多了一步开辟堆内存，把 this 指向该堆内存，代码完成之后，默认返回 this
      原型模式  比构造函数模式多了一个 prototype
     */

     var per ={
         name:123,
         age:234,
         eat(){},
         play(){}
     }

     function factory(name,age){
         var obj ={
             name,
             age,
             eat(){},
             play(){}
         }
         return obj
     }
     var per2 = factory('李四',29)
     var per2 = factory('李四2',29)

     function person(name,age){
         this.name = name;
         this.age  = age;
         this.eat  = function eat(){}
         this.play  = function play(){}
     }
     var per3 = new person('销毁',22)
     console.log(per3)


     function person(name,age){
         this.name = name;
         this.age  = age;
         this.eat  = function eat(){
             console.log(`${this.name}吃饭`)
         }
         this.play  = function play(){
            console.log(`${this.name}玩`)
         }
     }

     person.prototype.eat = function eat() {
            console.log(`${this.name}吃饭`)
        }
     person.prototype.eat = function eat() {
            console.log(`${this.name}玩`)
        }  

    var per4 = new person('张三',22) 
    var per5 = new person('李四',25) 
    console.log(per4,per5)

   /*
   类的原型其实就是一个堆内存（对象）
     每一个函数(类)都有一个 prototype 的属性 指向自己的原型
     每一个对象（实例）都有一个 __proto__的属性 指向所属类的原型
     每一个原型 都有一个 constructor 属性，指向其构造函数本身

    原型链：
         原型链就是对象中的属性的查找机制，先在自己身上查找，没有的话 就通过__proto__去所属类的原型上接着查找，原型上没有的话，就在通过__proto__向上级原型查找，一直找到 基类的原型，有的话就返回对应的值，没有的话就是undefined
   */
</script>