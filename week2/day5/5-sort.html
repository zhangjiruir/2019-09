<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <ul class="box">
        <li>姓名是：<span>小明</span> 年龄是 <span>20</span></li>
        <li>姓名是：<span>小明</span> 年龄是 <span>20</span></li>
        <li>姓名是：<span>小明</span> 年龄是 <span>20</span></li>
    </ul>
</body>
</html>
<script>
    let box =document.querySelector('.box');
    let ary = [
        {name:'小明',age:10},
        {name:'小明2',age:20},
        {name:'小明3',age:30},
        {name:'小明4',age:40}
    ];
    let [a,,,,b]=[1,2,3,4,5];//数组的解构赋值 是按照位置决定的
    let{x,y,z} = {x:12,a:123,v:345,y:666};//x=12 y=666 z=undeifnd;对象的解构赋值是按照属性名对应的


    function renderHtml(ary){
        // 该函数是吧后台给的数据渲染到页面上
        var str = '';
        ary.forEach((item) => {
            let {name,age} =item;//对象的解构赋值
            str+=`<li>姓名是：<span>${item.name}</span> 年龄是 <span>${item.age}</span></li>`
        });
        box.innerHTML = str;
    }
    var olis = document.getElementsByTagName('li');
    var olis2 = document.querySelectorAll('li');
    console.log(olis,olis2);
    renderHtml(ary);
    console.log(olis,olis2);// olis 自动更新了；olis2没有任何改变

    // olis 是更新之后的集合
    let arr = [...olis];
    arr.sort((a,b)=>{
        let aName = a.getElementsByTagName('span')[0].innerHTML;
        let bName = b.getElementsByTagName('span')[0].innerHTML;
        return bName.localeCompare(aName)
    })
    console.log(arr);//按照姓名排好序的 数组
    arr.forEach(item=>{
        box.appendChild(item);//因为这些元素都是在页面上已经存在的，所以append 只会改变位置，不会新增
    })

    // DOM 的回流和重绘
    // 只要改动 DOM 结构 或者元素的位置 都会引发 DOM回流 ；回流：浏览器要重新渲染一遍结构
    // 重绘 只是让页面重新渲染一下 css样式；比如 改变字体颜色，改变背景图等
</script>