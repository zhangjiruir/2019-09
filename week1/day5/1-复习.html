<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /*
      1.变量提升
         代码执行之前，先把 var 和function 关键字声明的变量提前声明，带var的 只声明 不定义，
         带function 声明又定义，前提是不在 块级作用域内部

         暂时性死区
         在 let 和 const 声明的变量之上；不能使用对应的变量，一经使用就报错

      2.堆栈内存
          栈内存 存储值类型，提供代码的运行环境；
          堆内存 存储引用数据类型，
          

          对象的存储过程： 先开辟一个堆内存，把键值对一对一对的存储进去，存储完成之后，把地址赋给对应的变量
          函数的存储过程： 先开辟一个堆内存，把函数体当做字符串存储到该内存中，存储外层之后把地址给函数名

          作用域：都是栈内存,代码能够起作用的区域
             全局作用域：页面一打开 就会形成一个全局作用域：window
             私有作用域：函数执行形的作用域，函数执行的过程：先开辟一个作用域，形参赋值，变量提升 代码执行
             块状作用域： es6特有的 针对let和const能够起作用，对于var 没有任何反应

             全局变量：全局声明的变量
             私有变量：私有作用域声明的变量，对于函数来说还有形参
            var  let const  三者有什么区别？
            1.var 可以重复声明，let const不能重复声明；let是变量 const是常量
            2.let const 没有变量提升，存在暂时性死区
            3.let cont  能够识别块级作用域
            
            垃圾回收  堆栈内存销毁：
                堆内存的销毁：谷歌浏览器 会定期的查看堆内存空间，把空间中没有被引用的堆内存回收
                栈内存的销毁：全局作用域销毁；只有当页面关闭的时候才会销毁
                             私有作用域销毁：只有当函数的返回值是一个引用数据类型的时候，才不会被销毁

        闭包：一个不销毁的作用域，一是 保护私有变量 不受外界污染， 二是 存储值 
        闭包的缺点：闭包是一个不销毁的作用域，用的多了，会造成内存泄漏   

        3.this 函数的执行主体，谁让这个函数执行了
             1.事件绑定中的this  都是当前操作的元素
             2.自执行函数中的this 是window
             3.一般函数执行都是看点的，点前面是谁 this就是谁，没点的都是 window



    */
    var a = 10;
    function f(){
        console.log(a)
        // let a = 12;
    }

    var obj = {
        a:1,
        b:(function(n){
            return n*100
        })(2),
    }
</script>